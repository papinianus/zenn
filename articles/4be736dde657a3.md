---
title: 'Pleasanter でのワークフロー機能実現のためのアーキテクチャ'
emoji: '🍊'
type: 'idea' # tech: 技術記事 / idea: アイデア
topics: ['pleasanter']
published: true
---

[2022 個人アドベントカレンダー](https://qiita.com/advent-calendar/2022/papinianus) の記事です。

## 目的

「プロセス」機能を使って「ワークフロー」を実現するためのアーキテクチャの提案

### 現状の課題感

[FAQ](https://pleasanter.org/manual/faq-process-workflow)やこれの参考実装であるデモサイトの"稟議申請の例"では、テーブルに機能を盛り込んでいる。

FAQ や Web での記事を確認しても、基本的に特定目的のテーブルを作成し、そのテーブルにコードや設定を作り込んで機能実現を図っている。

テーブル内にロジックを盛り込んでいくと、技術負債化してしまうこと以上に、ワークフロー的機能を実現するにあたって次の問題がある

- プロセスの一括実行は、同じ名前のプロセスがあると実用性がない
  - 複数回の「承認」があると、「承認」が複数出る
- プロセスの条件(ビューも同じだが)はユーザ属性に基づく動的な内容を右辺値にできない
  - つまり「自分チェック」を担当者/管理者以外には使えない
    - ^ 複数の承認がある場合、担当者や管理者をデータ変更機能で入れ換えるなどの対応を要する
  - 自組織、はないので、レコードのアクセス制御で閲覧/更新権限を分類型に基づいて設定することで、コントロールすることになる
    - 承認が誰に回覧されているかと、承認を待っている内容そのもののアクセス権限が混在してしまう
      - 権限管理が煩雑になる要因でもあり、ワークフローの進み具合を概観したりすることが困難になる

オンライン化するにあたって業務を見直して無駄な承認ステップを減らす、といったことは前提としても、いざどうしても多段階の承認をしようとしたとき、紙(や Excel ファイル)を回覧していたイメージに固まり、システム化の恩恵を得られていない。

### 今回検討するアーキテクチャ

ここでは、承認依頼内容そのものと承認行為を別テーブルにするアーキテクチャを検討する

具体的に嬉しくなる要素として

- 承認行為と承認内容の分離
  - 承認を得るべき点(決裁)と、記載内容における書式チェックは本質的に独立している。これらを独立に承認・チェックできる仕組みが実現できる
- 一括承認の実用的な実行
  - 承認をするテーブルでは、自分が更新権があるレコードに対して「承認」または「却下」だけが選択できるようにする。
  - また、依頼内容によらず、まとめての承認が可能となる
- ワークフローの承認パス設計とユーザインターフェイスの独立(UI の一貫性)
  - ワークフローを行う内容ごとに、承認回数や方式(誰かひとりでも承認すればいいのか、多数決なのか、全員が認めるのか、強権的な権限があるのか)が異なり得るが、そうした要素によって、一括承認のようなユーザビリティが変動しないようにする。

## 実装案

### テーブル設計

ワークフローの起案内容をもつテーブル群と承認だけをするテーブルの 2 パターンに分ける。
起案テーブルは、そこに記載された承認依頼先に応じたレコードを、承認テーブルに作成する。
なお、複数の起案テーブルが共通の承認テーブルにレコード作成したり、特定の起案テーブルが、依頼先(人か組織か)によって複数の承認テーブルにレコードを作成したりしてもよさそう。

- 承認テーブル

承認依頼内容を参照させるため、テーブルのリンクを設定する想定。
ただ、承認テーブルにレコードを作成するのはスクリプトでしか実行できないので、あえて機能としてのリンクテーブルを作らなくてもよい。
この場合、承認テーブルにはサマリとして文字として情報を渡し、さらに分類型でアンカーを有効にして依頼へのリンクをつける、といった対応が想定できる。

このテーブルは、管理者や担当者、分類型項目を使って、レコードのアクセス権限(読取/更新)を設定し、承認できるものしか見えない、かたちにする。

- 起案テーブル

承認フローのビジネスロジックをスクリプトとして保持する。このスクリプトにより、承認テーブルのレコードを作成したり、その内容によってステータスをかえたりする。

このため、承認を誰またはどの組織にするかの情報や承認テーブルのレコードの情報を保持しておく(レコードは保持しなくて、探すことも可能ではあるが…)

### 子テーブル(承認)

- サイトのアクセス制御で新規作成のみ許可
- ユーザ/組織項目を用意 → 承認者
  - ユーザは管理者、担当者を使う
  - 組織やグループは分類を使う
- レコードのアクセス制御で、承認者に読取と更新権限を付与
- 状況による制御で、承認行為が可能でない場合、読取専用とする
- プロセスで、承認と却下ボタンを用意 → 完了にする
- サーバースクリプトで、更新後に親を Update する

### 親テーブル(起案)

- プロセスで依頼ボタン
- サーバースクリプトで、依頼が行われたとき、子を作成

- 親テーブル
  - 依頼ボタン → 子作成(プロセス、さばすく)
  - 子 update 連動(さばすく)
  - ロジック(ぱら、順次 → ろっくをせんいかな、強行却下)(さばすく)
    - ロジックドリブンで、ステータスを完了に。

## つまったところ

- 状況の制御で状況が(未設定)のとき、読取専用とすると、既定値で値を指定していても、レコードを新規作成できなくなる
- サーバスクリプトで `items.New` とすると Status が 100 になっている。
  指定していないはずの、担当者も埋まった。
  `NewIssue` という関数で初期化されているのだが、具体的な値はまだまだ深い先で初期化されているようで、探索を諦めた。
  作り的に Create で SiteId を渡す前に初期化されるため、作成したいサイトの既定値が利用できない構造。辛すぎる。
